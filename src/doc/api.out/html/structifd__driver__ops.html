<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenCT: ifd_driver_ops Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ifd_driver_ops Struct Reference</h1><!-- doxytag: class="ifd_driver_ops" -->
<p>Driver operations.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="driver_8h_source.html">driver.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30d592e85bcecf0d17496945691553e5"></a><!-- doxytag: member="ifd_driver_ops::default_protocol" ref="a30d592e85bcecf0d17496945691553e5" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>default_protocol</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#a4d0a12472fdd8b0e191375f9e45d3e4a">open</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the reader.  <a href="#a4d0a12472fdd8b0e191375f9e45d3e4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#a3f5997fd33b1dce217d9bd593f1ed208">close</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the reader.  <a href="#a3f5997fd33b1dce217d9bd593f1ed208"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#a7094ace2992d15ef26188b8d6df373c1">change_parity</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int parity)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the communication protocol parity.  <a href="#a7094ace2992d15ef26188b8d6df373c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#a6fb5b6df0df9db9160fe0b0b3e72c367">change_speed</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, unsigned int speed)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the communication protocol speed.  <a href="#a6fb5b6df0df9db9160fe0b0b3e72c367"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#ac8e2637b8672bbea865187c13ff4f8a2">activate</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Activate the smart card reader.  <a href="#ac8e2637b8672bbea865187c13ff4f8a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#a181fd5e2945a30c2061b41d754194712">deactivate</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deactivate the smart card reader.  <a href="#a181fd5e2945a30c2061b41d754194712"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#adc21d782c198d7416b92d71ea0d97722">card_status</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, int *status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the card status.  <a href="#adc21d782c198d7416b92d71ea0d97722"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#a90b4f3ccf6b598d6668d7139fb44915e">card_reset</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, void *atr, size_t atr_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the card and fetch the ATR.  <a href="#a90b4f3ccf6b598d6668d7139fb44915e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#aae39b147262bb8263861d2d2864d40b3">card_request</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, time_t timeout, const char *message, void *atr, size_t atr_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prompts the insertion of a smart card in the reader and performs a card reset.  <a href="#aae39b147262bb8263861d2d2864d40b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#a26a33942a677859fb7259b5281ef4c0c">card_eject</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, time_t timeout, const char *message)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Eject the smart card.  <a href="#a26a33942a677859fb7259b5281ef4c0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#aa7cbfedeb9e6fc32b63471bf7e2b4c2a">output</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, const char *message)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output a message on the reader's display.  <a href="#aa7cbfedeb9e6fc32b63471bf7e2b4c2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#a8af0fbde7e571bc78c8a1375926e8685">perform_verify</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, unsigned int timeout, const char *prompt, const unsigned char *data, size_t data_len, unsigned char *resp, size_t resp_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request the PIN and have the card verify it.  <a href="#a8af0fbde7e571bc78c8a1375926e8685"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#a80db408c857b83db3ff1bfc73634d8b0">send</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, unsigned int dad, const unsigned char *buffer, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send an APDU using the currently selected protocol.  <a href="#a80db408c857b83db3ff1bfc73634d8b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#ab2ffe9b1a6d6cd550d7b2d97967c6081">recv</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, unsigned int dad, unsigned char *buffer, size_t len, long timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive an APDU response using the currently selected protocol.  <a href="#ab2ffe9b1a6d6cd550d7b2d97967c6081"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#aaa842fff3552548756b1ce9ab4ac4e27">set_protocol</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, int protocol)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select the smart card communication protocol.  <a href="#aaa842fff3552548756b1ce9ab4ac4e27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#a9418fa6dad65dbe40d9e8cf9a8df8c8d">transparent</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, const void *sbuf, size_t slen, void *rbuf, size_t rlen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transceive a protocol data unit.  <a href="#a9418fa6dad65dbe40d9e8cf9a8df8c8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#af02fe6c2243b3d0cc8debffdbd911bb8">sync_read</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, int proto, unsigned short addr, unsigned char *rbuf, size_t rlen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data from a synchronous smart card.  <a href="#af02fe6c2243b3d0cc8debffdbd911bb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#ab79070efbbc2dd3315d60cc1cf73752a">sync_write</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, int proto, unsigned short addr, const unsigned char *sbuf, size_t slen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write data to a synchronous smart card.  <a href="#ab79070efbbc2dd3315d60cc1cf73752a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37d8bf2c032f9885cf2b11b9bd7a8c7d"></a><!-- doxytag: member="ifd_driver_ops::escape" ref="a37d8bf2c032f9885cf2b11b9bd7a8c7d" args=")(ifd_reader_t *reader, int slot, const void *sbuf, const size_t slen, void *rbuf, size_t rlen)" -->
int(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>escape</b> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, const void *sbuf, const size_t slen, void *rbuf, size_t rlen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#a2dc4c60beed7c0d987966fd623f047a9">before_command</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute before command.  <a href="#a2dc4c60beed7c0d987966fd623f047a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#a6f6294219881e4cb8a51a6e0980a416f">after_command</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute after command.  <a href="#a6f6294219881e4cb8a51a6e0980a416f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#a02f17628fb434fb81049e2c9311c04a6">get_eventfd</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *, short *events)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get event fd.  <a href="#a02f17628fb434fb81049e2c9311c04a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#a54a0051fd2070d6ee2c8d8047ff1cfea">event</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *, int *status, size_t status_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event callback.  <a href="#a54a0051fd2070d6ee2c8d8047ff1cfea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#a28aa6a49c53f87280d0fd6854e038313">error</a> )(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Error callback.  <a href="#a28aa6a49c53f87280d0fd6854e038313"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Driver operations. </p>

<p>Definition at line <a class="el" href="driver_8h_source.html#l00020">20</a> of file <a class="el" href="driver_8h_source.html">driver.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="ac8e2637b8672bbea865187c13ff4f8a2"></a><!-- doxytag: member="ifd_driver_ops::activate" ref="ac8e2637b8672bbea865187c13ff4f8a2" args=")(ifd_reader_t *reader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#ac8e2637b8672bbea865187c13ff4f8a2">activate</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Activate the smart card reader. </p>
<p>This function performs all necessary operations to activate the smart card reader. After activation, the reader must be able to accept card status commands (card_status).</p>
<p>Reader activation is currently performed once at startup, before calling card_status in response to CT_CMD_STATUS (is it really needed, as the reader was activated at startup ?), and when probing for synchronous cards.</p>
<p>Called by: ifd_activate. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f6294219881e4cb8a51a6e0980a416f"></a><!-- doxytag: member="ifd_driver_ops::after_command" ref="a6f6294219881e4cb8a51a6e0980a416f" args=")(ifd_reader_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#a6f6294219881e4cb8a51a6e0980a416f">after_command</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute after command. </p>
<p>Provides a chance to setup device to accept events.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, 0 if success. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dc4c60beed7c0d987966fd623f047a9"></a><!-- doxytag: member="ifd_driver_ops::before_command" ref="a2dc4c60beed7c0d987966fd623f047a9" args=")(ifd_reader_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#a2dc4c60beed7c0d987966fd623f047a9">before_command</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute before command. </p>
<p>Provides a chance to setup device to accept new commands.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, 0 if success. </dd></dl>

</div>
</div>
<a class="anchor" id="a26a33942a677859fb7259b5281ef4c0c"></a><!-- doxytag: member="ifd_driver_ops::card_eject" ref="a26a33942a677859fb7259b5281ef4c0c" args=")(ifd_reader_t *reader, int slot, time_t timeout, const char *message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#a26a33942a677859fb7259b5281ef4c0c">card_eject</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, time_t timeout, const char *message)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Eject the smart card. </p>
<p>This function ejects the smart card or prompt the user to remove the card by displaying the message <em>message</em>. The optional parameter <em>timeout</em>, if not equal to zero, gives the card removal timeout in seconds.</p>
<p>It is not clear if this function should deactivate the smart card first, or if the caller must deactivate the card before calling card_eject.</p>
<p>Called by: ifd_card_eject. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aae39b147262bb8263861d2d2864d40b3"></a><!-- doxytag: member="ifd_driver_ops::card_request" ref="aae39b147262bb8263861d2d2864d40b3" args=")(ifd_reader_t *reader, int slot, time_t timeout, const char *message, void *atr, size_t atr_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#aae39b147262bb8263861d2d2864d40b3">card_request</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, time_t timeout, const char *message, void *atr, size_t atr_len)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prompts the insertion of a smart card in the reader and performs a card reset. </p>
<p>This function prompts the user to insert a smart card in the reader. For card readers equipped with a display, the optional message message should be displayed to the user. The optional parameter timeout, if not equal to zero, gives the prompt timeout in seconds.</p>
<p>If a card is inserted before the timeout elapses, the card is reset and the ATR is fetched. See card_reset for more information.</p>
<p>Called by: ifd_card_request </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, length of the ATR if success. </dd></dl>

</div>
</div>
<a class="anchor" id="a90b4f3ccf6b598d6668d7139fb44915e"></a><!-- doxytag: member="ifd_driver_ops::card_reset" ref="a90b4f3ccf6b598d6668d7139fb44915e" args=")(ifd_reader_t *reader, int slot, void *atr, size_t atr_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#a90b4f3ccf6b598d6668d7139fb44915e">card_reset</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, void *atr, size_t atr_len)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the card and fetch the ATR. </p>
<p>This function resets the smart card and reads the Answer To Reset (ATR). The ATR will be stored in the slot structure by OpenCT, so the driver <b>must not</b> store the ATR itself in the slot structure.</p>
<p>When resetting the card, the driver is allowed to select a protocol. If no protocol is selected when this function returns (assuming it returns successfully), OpenCT will try to select the protocol automatically (see set_protocol).</p>
<p>Called by: ifd_card_request. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, length of the ATR if success. </dd></dl>

</div>
</div>
<a class="anchor" id="adc21d782c198d7416b92d71ea0d97722"></a><!-- doxytag: member="ifd_driver_ops::card_status" ref="adc21d782c198d7416b92d71ea0d97722" args=")(ifd_reader_t *reader, int slot, int *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#adc21d782c198d7416b92d71ea0d97722">card_status</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, int *status)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the card status. </p>
<p>This function returns the current card status for a given slot. status is a bitfield which currently accepts the following flags:</p>
<ul>
<li><code>IFD_CARD_PRESENT</code> (1) A card is present in the slot. </li>
<li><code>IFD_CARD_STATUS_CHANGED</code> (2) The slot status has changed since last call.</li>
</ul>
<p>Beside using IFD_CARD_STATUS_CHANGED, OpenCT checks if the card status has changed by comparing the current status value with the previous status value. If the value of the IFD_CARD_PRESENT has changed, OpenCT will set the IFD_CARD_STATUS_CHANGED <b>on the client side</b>.</p>
<p>On the server side, setting IFD_CARD_STATUS_CHANGED will also set atr_len to 0 for the given slot. As atr_len is only checked in ifd_protocol_select, and as that function is only called in ifd_card_request right after assigning a value to atr_len, this is currently pointless and a reader driver should <b>not</b> set IFD_CARD_STATUS_CHANGED if its only source of information is a change of the IFD_CARD_PRESENT flag between the current call and the previous one.</p>
<p>Called by: ifd_card_status. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a7094ace2992d15ef26188b8d6df373c1"></a><!-- doxytag: member="ifd_driver_ops::change_parity" ref="a7094ace2992d15ef26188b8d6df373c1" args=")(ifd_reader_t *reader, int parity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#a7094ace2992d15ef26188b8d6df373c1">change_parity</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int parity)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the communication protocol parity. </p>
<p>This function is only used for asynchronous smart cards with serial readers, and only if the reader doesn't auto-detect the protocol parity.</p>
<p>Depending on the smart card communication protocol convention (either direct or inverse, see ISO-7816-3, 6.4), the communication between the reader and the smart card uses odd or even parity. If most readers handle smart card protocol convention transparently, the most simple ones map the smart card lines directly on the serial port or require the user to configure the reader according smart card communication protocol parity. For those readers, OpenCT will try both parities (starting with even) when reading the ATR.</p>
<p>This function, if available, configures the reader and/or the serial port according to the smart card communication protocol parity. It is used by ifd_card_request only.</p>
<p>Accepted values for <em>parity</em> are</p>
<ul>
<li><code>IFD_SERIAL_PARITY_ODD</code> (1) </li>
<li><code>IFD_SERIAL_PARITY_EVEN</code> (2)</li>
</ul>
<p>Called by: ifd_card_request. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a6fb5b6df0df9db9160fe0b0b3e72c367"></a><!-- doxytag: member="ifd_driver_ops::change_speed" ref="a6fb5b6df0df9db9160fe0b0b3e72c367" args=")(ifd_reader_t *reader, unsigned int speed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#a6fb5b6df0df9db9160fe0b0b3e72c367">change_speed</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, unsigned int speed)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the communication protocol speed. </p>
<p>It is not clear if this function was intended to change the communication speed between the host and the reader, the reader and the smart card, or both, as it is currently not used (ifd_set_speed is never called).</p>
<p>Called by: ifd_set_speed. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f5997fd33b1dce217d9bd593f1ed208"></a><!-- doxytag: member="ifd_driver_ops::close" ref="a3f5997fd33b1dce217d9bd593f1ed208" args=")(ifd_reader_t *reader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#a3f5997fd33b1dce217d9bd593f1ed208">close</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close the reader. </p>
<p>This function frees all the resources allocated by *open. If made possible by the hardware, the reader and all its slots must be powered off.</p>
<p>The device will be closed by ifd_close, and must <b>not</b> be closed by this function.</p>
<p>OpenCT currently never calls ifd_close, so the close function if not used.</p>
<p>Called by: ifd_close. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a181fd5e2945a30c2061b41d754194712"></a><!-- doxytag: member="ifd_driver_ops::deactivate" ref="a181fd5e2945a30c2061b41d754194712" args=")(ifd_reader_t *reader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#a181fd5e2945a30c2061b41d754194712">deactivate</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deactivate the smart card reader. </p>
<p>Reader deactivation is currently performed only when probing for synchronous cards. OpenCT deactivates and reactivates the reader before trying to access the card.</p>
<p>Called by: ifd_deactivate. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a28aa6a49c53f87280d0fd6854e038313"></a><!-- doxytag: member="ifd_driver_ops::error" ref="a28aa6a49c53f87280d0fd6854e038313" args=")(ifd_reader_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#a28aa6a49c53f87280d0fd6854e038313">error</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Error callback. </p>
<p>Will be called if an error is set on event fd. May be NULL if unsupported.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, 0 if success. If reader should be freed, return an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a54a0051fd2070d6ee2c8d8047ff1cfea"></a><!-- doxytag: member="ifd_driver_ops::event" ref="a54a0051fd2070d6ee2c8d8047ff1cfea" args=")(ifd_reader_t *, int *status, size_t status_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#a54a0051fd2070d6ee2c8d8047ff1cfea">event</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *, int *status, size_t status_size)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Event callback. </p>
<p>Will be called if an event is set. May be NULL if unsupported.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, 0 if success. </dd></dl>

</div>
</div>
<a class="anchor" id="a02f17628fb434fb81049e2c9311c04a6"></a><!-- doxytag: member="ifd_driver_ops::get_eventfd" ref="a02f17628fb434fb81049e2c9311c04a6" args=")(ifd_reader_t *, short *events)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#a02f17628fb434fb81049e2c9311c04a6">get_eventfd</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *, short *events)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get event fd. </p>
<p>This will allow the mainloop to wait for event instead of polling. May be NULL if unsupported.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>fd. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d0a12472fdd8b0e191375f9e45d3e4a"></a><!-- doxytag: member="ifd_driver_ops::open" ref="a4d0a12472fdd8b0e191375f9e45d3e4a" args=")(ifd_reader_t *reader, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#a4d0a12472fdd8b0e191375f9e45d3e4a">open</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, const char *name)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open the reader. </p>
<p>This function opens the device named <em>name</em> and initialize the reader structure. The slots' dad should be set here.</p>
<p>OpenCT calls the open function once at startup.</p>
<p>Called by: ifd_open. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7cbfedeb9e6fc32b63471bf7e2b4c2a"></a><!-- doxytag: member="ifd_driver_ops::output" ref="aa7cbfedeb9e6fc32b63471bf7e2b4c2a" args=")(ifd_reader_t *reader, const char *message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#aa7cbfedeb9e6fc32b63471bf7e2b4c2a">output</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, const char *message)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output a message on the reader's display. </p>
<p>Called by: ifd_output. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a8af0fbde7e571bc78c8a1375926e8685"></a><!-- doxytag: member="ifd_driver_ops::perform_verify" ref="a8af0fbde7e571bc78c8a1375926e8685" args=")(ifd_reader_t *reader, int slot, unsigned int timeout, const char *prompt, const unsigned char *data, size_t data_len, unsigned char *resp, size_t resp_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#a8af0fbde7e571bc78c8a1375926e8685">perform_verify</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, unsigned int timeout, const char *prompt, const unsigned char *data, size_t data_len, unsigned char *resp, size_t resp_len)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request the PIN and have the card verify it. </p>
<p>This function prompts the user to enter his PIN code and have the smart card verify the code. The optional parameter <em>timeout</em>, if not equal to zero, gives the PIN request timeout.</p>
<p>The two bytes status (SW1-SW2) is copied in the <em>resp</em> buffer. If the status indicates a known error (IFD_ERROR_USER_TIMEOUT, IFD_ERROR_USER_ABORT, IFD_ERROR_PIN_MISMATCH) the error code is returned. Otherwise the length of the response (2) is returned.</p>
<p>Called by: ifd_perform_verify. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, size of the response (2) if success or unknown error. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2ffe9b1a6d6cd550d7b2d97967c6081"></a><!-- doxytag: member="ifd_driver_ops::recv" ref="ab2ffe9b1a6d6cd550d7b2d97967c6081" args=")(ifd_reader_t *reader, unsigned int dad, unsigned char *buffer, size_t len, long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#ab2ffe9b1a6d6cd550d7b2d97967c6081">recv</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, unsigned int dad, unsigned char *buffer, size_t len, long timeout)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive an APDU response using the currently selected protocol. </p>
<p>This function is called by all non-transparent protocols to receive an APDU response from a device. The device address is set by the <em>dad</em> parameter which takes the same values as for the send function.</p>
<p>The <em>dad</em> parameter is currently unused by all drivers, even the Kaan driver which takes care to initialize it correctly in the open function.</p>
<p>Called by: ifd_recv_response. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, number of bytes received if success. </dd></dl>

</div>
</div>
<a class="anchor" id="a80db408c857b83db3ff1bfc73634d8b0"></a><!-- doxytag: member="ifd_driver_ops::send" ref="a80db408c857b83db3ff1bfc73634d8b0" args=")(ifd_reader_t *reader, unsigned int dad, const unsigned char *buffer, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#a80db408c857b83db3ff1bfc73634d8b0">send</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, unsigned int dad, const unsigned char *buffer, size_t len)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send an APDU using the currently selected protocol. </p>
<p>This function is called by all non-transparent protocols to send an APDU to a device. The device address is set by the <em>dad</em> parameter which is one of</p>
<ul>
<li><code>IFD_DAD_HOST</code> (0) Host (PC) - what's the point ? </li>
<li><code>IFD_DAD_IFD</code> (1) The APDU is sent to the reader </li>
<li><code>IFD_DAD_ICC1</code> (2) The APDU is sent to the first smart card </li>
<li><code>IFD_DAD_ICC2</code> (3) The APDU is sent to the second smart card</li>
</ul>
<p>The <em>dad</em> parameter is currently unused by all drivers, even the Kaan driver which takes care to initialize it correctly in the open function.</p>
<p>Called by: ifd_send_command. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, number of bytes sent if success. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa842fff3552548756b1ce9ab4ac4e27"></a><!-- doxytag: member="ifd_driver_ops::set_protocol" ref="aaa842fff3552548756b1ce9ab4ac4e27" args=")(ifd_reader_t *reader, int slot, int protocol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#aaa842fff3552548756b1ce9ab4ac4e27">set_protocol</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, int protocol)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Select the smart card communication protocol. </p>
<p>The smart card communication protocol is selected by OpenCT when the card is reset (either by reset_card or request_card), and can be overriden by the user by sending a CT_CMD_SET_PROTOCOL command.</p>
<p>OpenCT doesn't perform a PPS exchange with the card itself, but selects the first protocol offered by the ATR at reset time by calling set_protocol. If the reader performs the PPS exchange with the card, the selected protocol can be set manually by the driver (by setting slot-&gt;proto) and set_protocol will not be called.</p>
<p>It is not clear what the side effects of CT_CMD_SET_PROTOCOL (should it reset the card ?) should be and if that function is used at all by applications. Isn't the default protocol good enough ? I would have thought that set_protocol was meant to be called only right after reset, to select the protocol and instruct the driver to perform a PPS exchange.</p>
<p>Called by: ifd_set_protocol, ifd_select_protocol. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>

</div>
</div>
<a class="anchor" id="af02fe6c2243b3d0cc8debffdbd911bb8"></a><!-- doxytag: member="ifd_driver_ops::sync_read" ref="af02fe6c2243b3d0cc8debffdbd911bb8" args=")(ifd_reader_t *reader, int slot, int proto, unsigned short addr, unsigned char *rbuf, size_t rlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#af02fe6c2243b3d0cc8debffdbd911bb8">sync_read</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, int proto, unsigned short addr, unsigned char *rbuf, size_t rlen)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data from a synchronous smart card. </p>
<p>This function writes <em>rlen</em> bytes to the smart card, starting at address <em>addr</em>. The <em>proto</em> parameter specifies the desired communication protocol. The driver must set the protocol before reading data, or return an error if the protocol is not supported.</p>
<p>Called by: sync_read at proto-sync.c, sync_write at proto-sync.c. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, number of bytes read if success. </dd></dl>

</div>
</div>
<a class="anchor" id="ab79070efbbc2dd3315d60cc1cf73752a"></a><!-- doxytag: member="ifd_driver_ops::sync_write" ref="ab79070efbbc2dd3315d60cc1cf73752a" args=")(ifd_reader_t *reader, int slot, int proto, unsigned short addr, const unsigned char *sbuf, size_t slen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#ab79070efbbc2dd3315d60cc1cf73752a">sync_write</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, int proto, unsigned short addr, const unsigned char *sbuf, size_t slen)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write data to a synchronous smart card. </p>
<p>This function reads <em>slen</em> bytes from the smart card, starting at address <em>addr</em>. The <em>proto</em> parameter specifies the desired communication protocol. The driver must set the protocol before writing data, or return an error if the protocol is not supported.</p>
<p>Called by: sync_write at proto-sync.c. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, number of bytes written if success. </dd></dl>

</div>
</div>
<a class="anchor" id="a9418fa6dad65dbe40d9e8cf9a8df8c8d"></a><!-- doxytag: member="ifd_driver_ops::transparent" ref="a9418fa6dad65dbe40d9e8cf9a8df8c8d" args=")(ifd_reader_t *reader, int slot, const void *sbuf, size_t slen, void *rbuf, size_t rlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structifd__driver__ops.html#a9418fa6dad65dbe40d9e8cf9a8df8c8d">transparent</a>)(<a class="el" href="structifd__reader.html">ifd_reader_t</a> *reader, int slot, const void *sbuf, size_t slen, void *rbuf, size_t rlen)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transceive a protocol data unit. </p>
<p>This function is used by the transparent protocol, when the driver and/or the reader accepts raw PDUs directly. When using the transparent protocol, the PDUs sent by the client are forwarded directly to the driver without being mangled by OpenCT. If the driver and/or the reader can't accept the PDUs directly (for instance when the reader doesn't support Case 4 APDUs in T=0 protocol), the driver should instanciate the appropriate protocol handler to pre-process the PDUs. In that case, the send and recv functions will be used instead of the transparent function.</p>
<p>Called by: trans_transceive at proto-trans.c </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, size of the response if success. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="driver_8h_source.html">driver.h</a></li>
</ul>
</div>
<hr>
<table width="100%"><tr><td>libp11, Copyright (C) 2005 Olaf Kirch &lt;okir@lst.de&gt;</td><td align="right"><a href="http://www.opensc-project.org"><img src="opensc-logo.gif" alt="OpenSC-Project.org Logo" border="0"/></a></td></tr></table>
